#!/usr/bin/env ruby  

require 'rubygems'
require 'date'
require 'open-uri'
require 'nokogiri' 


MEDLINE_XML_BASE_URL = "http://www.nlm.nih.gov/medlineplus/xml/vocabulary/mplus_"

# groups.xml
# vocab.xml


class MedlineVocab

  SATURDAY = 6
  DAYS_PER_WEEK = 7

  CACHE_DATA_PATH = "."

  def self.saturday_on_or_before( date )

	day_of_week = date.wday 

	most_recent_saturday = if day_of_week >= SATURDAY
		date - day_of_week + SATURDAY
	else
		date - day_of_week - DAYS_PER_WEEK + SATURDAY
	end

  end

  def initialize( xml_data )
	@xml_data = xml_data
	@doc = Nokogiri::XML( xml_data )
  end

  def self.xml_base_name_for_date( date = nil )
	most_recent_saturday = saturday_on_or_before( date || Date.today )
	sat_s = most_recent_saturday.strftime( "%Y-%m-%d" )
	return "vocab_#{sat_s}"
  end

  def self.for_date( date = nil )
	vocab_xml_fns = "#{xml_base_name_for_date( date )}.xml"
	cached_data_path = File.join( CACHE_DATA_PATH, vocab_xml_fns )
	xml_data = if File.exist?( cached_data_path )
		File.open( cached_data_path ) { |cached_file| cached_file.read }	
	else
		vocab_xml_url = "#{MEDLINE_XML_BASE_URL}#{vocab_xml_fns}"
		puts "fetching #{vocab_xml_url}"
		remote_data = open( vocab_xml_url ) { |remote| remote.read }
		File.open( cached_data_path, "w" ) { |cached_data_file| cached_data_file.write( remote_data ) }	
		remote_data
	end
	return self.new( xml_data )
  end

  def doc
	@doc
  end

end



wanted_topic_ids = ARGV.collect { |arg| arg.to_i }.uniq

topic_names = {}
topic_nodes = {}

unless wanted_topic_ids.size > 0
	raise "usage: closure <topic_id> ..."
end

puts "wanted topic ids: #{wanted_topic_ids.join(", ")}"

vocab = MedlineVocab.for_date
vocab.doc.xpath("//MedicalTopic").each { |topic_node| 

	tid  = topic_node.at_xpath('ID').text.to_i rescue nil
	lang = topic_node["langcode"] rescue -1
	name = topic_node.at_xpath("MedicalTopicName").text rescue ""
	lmtid = topic_node.at_xpath('LanguageMappedTopicID').text.to_i rescue nil

	if wanted_topic_ids.include? tid 
		puts "found: #{tid} -- #{name}"
		unless lmtid.nil? or wanted_topic_ids.include?( lmtid )
			wanted_topic_ids << lmtid
			puts "  needs topic #{lmtid}"
		end
	end

	topic_names[tid] = name
	topic_nodes[tid] = topic_node
}

wanted_topic_ids.each { |tid|
	unless topic_names.key? tid
		puts "missing: #{tid}"
	end
}

puts "closure: #{wanted_topic_ids.join(", ")}"

n_removed = 0
topic_nodes.each { |tid, topic_node|
	if wanted_topic_ids.include? tid
		related_topics = topic_node.at_xpath('RelatedTopics')
		ext_related_topic_refs = []
		keeping_rtids = []
		unless related_topics.nil?
			related_topics.xpath( 'RelatedTopic' ).each { |related_topic|
				rtid_s = related_topic.attr('IDREF') 
				rtid_s['T'] = ''
				rtid = rtid_s.to_i
				if wanted_topic_ids.include? rtid
					keeping_rtids << rtid
				else
					ext_related_topic_refs << related_topic 
				end
			}
			if keeping_rtids.size == 0
				related_topics.remove
				puts "removed all related topics for #{tid}"
			else
				ext_related_topic_refs.each { |related_topic|
					related_topic.remove
				}
				puts "removed #{ext_related_topic_refs.size} related topics for #{tid}"
			end
		end
	else
		topic_node.remove 
		n_removed += 1
	end
}

puts "removed #{n_removed} topics"

closure_xml_fn = "#{MedlineVocab.xml_base_name_for_date}_closure.xml"
puts "writing to #{closure_xml_fn}"

File.open( closure_xml_fn, "w" ) { |f| vocab.doc.write_to( f, :encoding => 'UTF-8', :indent => 2 ) }


