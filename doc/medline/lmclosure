#!/usr/bin/env ruby  

require 'rubygems'
require 'date'
require 'open-uri'
require 'nokogiri' 


MEDLINE_XML_BASE_URL = "http://www.nlm.nih.gov/medlineplus/xml/vocabulary/mplus_"

# groups.xml
# vocab.xml


class MedlineVocab

  SATURDAY = 6
  DAYS_PER_WEEK = 7

  CACHE_DATA_PATH = "."

  def self.saturday_on_or_before( date )

	day_of_week = date.wday 

	most_recent_saturday = if day_of_week >= SATURDAY
		date - day_of_week + SATURDAY
	else
		date - day_of_week - DAYS_PER_WEEK + SATURDAY
	end

  end

  def initialize( xml_data )
	@xml_data = xml_data
	@doc = Nokogiri::XML( xml_data )
  end

  def self.for_date( date = nil )
	most_recent_saturday = saturday_on_or_before( date || Date.today )
	sat_s = most_recent_saturday.strftime( "%Y-%m-%d" )
	vocab_xml_fns = "vocab_#{sat_s}.xml"
	cached_data_path = File.join( CACHE_DATA_PATH, vocab_xml_fns )
	xml_data = if File.exist?( cached_data_path )
		File.open( cached_data_path ) { |cached_file| cached_file.read }	
	else
		vocab_xml_url = "#{MEDLINE_XML_BASE_URL}#{vocab_xml_fns}"
		puts "fetching #{vocab_xml_url}"
		remote_data = open( vocab_xml_url ) { |remote| remote.read }
		File.open( cached_data_path, "w" ) { |cached_data_file| cached_data_file.write( remote_data ) }	
		remote_data
	end
	return self.new( xml_data )
  end

  def doc
	@doc
  end

end



wanted_topics_ids = ARGV.collect { |arg| arg.to_i }.uniq

unless wanted_topic_ids.size > 0
	puts "usage: closure <topicid> ..."
end

puts "wanted topic ids: #{wanted_topic_ids.join(", ")}"

vocab = MedlineVocab.for_date
vocab.doc.xpath("//MedicalTopic").each { |topic_node| 

	tid  = topic_node.at_xpath('ID').text.to_i rescue nil
	lang = topic_node["langcode"] rescue -1
	name = topic_node.at_xpath("MedicalTopicName").text rescue ""
	lmtid = topic_node.at_xpath('LanguageMappedTopicID').text.to_i rescue nil
	summary = topic_node.at_xpath("FullSummary")
	summary_xml = if summary.nil?
		nil
	else
	 	summary.text 
	end

	syns_node = topic_node.at_xpath("Synonyms") 
	description = if syns_node.nil?
		name
	else
		synonyms = [] 
		syns_node.xpath('Synonyms').each { |syn_node| synonyms << syn_node.text }
		"#{name} (#{synonyms.join(", ")})"
	end

	topic = MedlineTopic.new( tid, lang, name, synonyms, lmtid, summary_xml )

	puts "%4d %2s %4d %s" % [topic.tid, topic.language[0..1], topic.lmtid || -1, description]

	if wanted_topic_ids.include? tid 
		puts "found: #{tid} -- #{name}"
		topic_ids << tid
		unless lmtid.nil?
			unless wanted_topic_ids.include? lmtid
			wanted_topic_ids << lmtid
			puts "  needs topic #{lmtid}"
		end
	end

	topic_names[tid] = name
}

wanted_topic_ids.each { |tid|
	unless topic_names.key? tid
		puts "missing: #{tid}"
	end

}

puts "closure: #{wanted_topic_ids.join(", ")}"

