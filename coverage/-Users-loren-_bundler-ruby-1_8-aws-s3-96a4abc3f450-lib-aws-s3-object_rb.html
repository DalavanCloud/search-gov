<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang='en' xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'>
  <head>
    <title>/Users/loren/.bundler/ruby/1.8/aws-s3-96a4abc3f450/lib/aws/s3/object.rb</title>
    <link href="screen.css" media="all" rel="stylesheet" type="text/css" />
    <link href="print.css" media="print" rel="stylesheet" type="text/css" />
    
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
    <script type="text/javascript" src="rcov.js"></script>
  </head>
  <body>
    <h1>Usasearch C0 Coverage Information - RCov</h1>
    <h2>/Users/loren/.bundler/ruby/1.8/aws-s3-96a4abc3f450/lib/aws/s3/object.rb</h2>

    

    <div class="report_table_wrapper">
      <table class='report' id='report_table'>
        <thead>
          <tr>
            <th class="left_align">Name</th>
            <th class="right_align">Total Lines</th>
            <th class="right_align">Lines of Code</th>
            <th class="left_align">Total Coverage</th>
            <th class="left_align">Code Coverage</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="left_align"><a href="-Users-loren-_bundler-ruby-1_8-aws-s3-96a4abc3f450-lib-aws-s3-object_rb.html">/Users/loren/.bundler/ruby/1.8/aws-s3-96a4abc3f450/lib/aws/s3/object.rb</a></td>
            <td class='right_align'><tt>612</tt></td>
            <td class='right_align'><tt>249</tt></td>
            <td class="left_align"><div class="percent_graph_legend"><tt class=''>70.92%</tt></div>
          <div class="percent_graph">
            <div class="covered" style="width:71px"></div>
            <div class="uncovered" style="width:29px"></div>
          </div></td>
            <td class="left_align"><div class="percent_graph_legend"><tt class=''>40.96%</tt></div>
          <div class="percent_graph">
            <div class="covered" style="width:41px"></div>
            <div class="uncovered" style="width:59px"></div>
          </div></td>
          </tr>
        </tbody>
      </table>
    </div>
    
    <h3>Key</h3>
    
    <div class="key"><pre><span class='marked'>Code reported as executed by Ruby looks like this...</span><span class='marked1'>and this: this line is also marked as covered.</span><span class='inferred'>Lines considered as run by rcov, but not reported by Ruby, look like this,</span><span class='inferred1'>and this: these lines were inferred by rcov (using simple heuristics).</span><span class='uncovered'>Finally, here's a line marked as not executed.</span></pre></div>

    <h3>Coverage Details</h3>

    <table class="details">
      <tbody>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1">1</a> module AWS</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2">2</a>   module S3</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line3">3</a>     # S3Objects represent the data you store on S3. They have a key (their name) and a value (their data). All objects belong to a</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line4">4</a>     # bucket.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line5">5</a>     #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line6">6</a>     # You can store an object on S3 by specifying a key, its data and the name of the bucket you want to put it in:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line7">7</a>     #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line8">8</a>     #   S3Object.store('me.jpg', open('headshot.jpg'), 'photos')</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line9">9</a>     #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line10">10</a>     # The content type of the object will be inferred by its extension. If the appropriate content type can not be inferred, S3 defaults</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line11">11</a>     # to &lt;tt&gt;binary/octet-stream&lt;/tt&gt;.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line12">12</a>     #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line13">13</a>     # If you want to override this, you can explicitly indicate what content type the object should have with the &lt;tt&gt;:content_type&lt;/tt&gt; option:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line14">14</a>     # </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line15">15</a>     #   file = 'black-flowers.m4a'</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line16">16</a>     #   S3Object.store(</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line17">17</a>     #     file,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line18">18</a>     #     open(file),</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line19">19</a>     #     'jukebox',</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line20">20</a>     #     :content_type =&gt; 'audio/mp4a-latm'</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line21">21</a>     #   )</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line22">22</a>     #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line23">23</a>     # You can read more about storing files on S3 in the documentation for S3Object.store.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line24">24</a>     #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line25">25</a>     # If you just want to fetch an object you've stored on S3, you just specify its name and its bucket:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line26">26</a>     #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line27">27</a>     #   picture = S3Object.find 'headshot.jpg', 'photos'</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line28">28</a>     #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line29">29</a>     # N.B. The actual data for the file is not downloaded in both the example where the file appeared in the bucket and when fetched directly. </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line30">30</a>     # You get the data for the file like this:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line31">31</a>     # </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line32">32</a>     #   picture.value</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line33">33</a>     #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line34">34</a>     # You can fetch just the object's data directly:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line35">35</a>     #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line36">36</a>     #   S3Object.value 'headshot.jpg', 'photos'</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line37">37</a>     #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line38">38</a>     # Or stream it by passing a block to &lt;tt&gt;stream&lt;/tt&gt;:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line39">39</a>     # </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line40">40</a>     #   open('song.mp3', 'w') do |file|</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line41">41</a>     #     S3Object.stream('song.mp3', 'jukebox') do |chunk|</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line42">42</a>     #       file.write chunk</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line43">43</a>     #     end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line44">44</a>     #   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line45">45</a>     #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line46">46</a>     # The data of the file, once download, is cached, so subsequent calls to &lt;tt&gt;value&lt;/tt&gt; won't redownload the file unless you </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line47">47</a>     # tell the object to reload its &lt;tt&gt;value&lt;/tt&gt;:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line48">48</a>     # </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line49">49</a>     #   # Redownloads the file's data</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line50">50</a>     #   song.value(:reload) </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line51">51</a>     #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line52">52</a>     # Other functionality includes:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line53">53</a>     #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line54">54</a>     #   # Check if an object exists?</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line55">55</a>     #   S3Object.exists? 'headshot.jpg', 'photos'</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line56">56</a>     #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line57">57</a>     #   # Copying an object</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line58">58</a>     #   S3Object.copy 'headshot.jpg', 'headshot2.jpg', 'photos'</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line59">59</a>     #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line60">60</a>     #   # Renaming an object</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line61">61</a>     #   S3Object.rename 'headshot.jpg', 'portrait.jpg', 'photos'</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line62">62</a>     #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line63">63</a>     #   # Deleting an object</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line64">64</a>     #   S3Object.delete 'headshot.jpg', 'photos'</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line65">65</a>     # </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line66">66</a>     # ==== More about objects and their metadata</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line67">67</a>     # </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line68">68</a>     # You can find out the content type of your object with the &lt;tt&gt;content_type&lt;/tt&gt; method:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line69">69</a>     # </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line70">70</a>     #   song.content_type</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line71">71</a>     #   # =&gt; &quot;audio/mpeg&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line72">72</a>     # </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line73">73</a>     # You can change the content type as well if you like:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line74">74</a>     # </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line75">75</a>     #   song.content_type = 'application/pdf'</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line76">76</a>     #   song.store</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line77">77</a>     # </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line78">78</a>     # (Keep in mind that due to limitiations in S3's exposed API, the only way to change things like the content_type</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line79">79</a>     # is to PUT the object onto S3 again. In the case of large files, this will result in fully re-uploading the file.)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line80">80</a>     # </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line81">81</a>     # A bevie of information about an object can be had using the &lt;tt&gt;about&lt;/tt&gt; method:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line82">82</a>     # </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line83">83</a>     #   pp song.about</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line84">84</a>     #   {&quot;last-modified&quot;    =&gt; &quot;Sat, 28 Oct 2006 21:29:26 GMT&quot;,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line85">85</a>     #    &quot;content-type&quot;     =&gt; &quot;binary/octet-stream&quot;,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line86">86</a>     #    &quot;etag&quot;             =&gt; &quot;\&quot;dc629038ffc674bee6f62eb64ff3a\&quot;&quot;,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line87">87</a>     #    &quot;date&quot;             =&gt; &quot;Sat, 28 Oct 2006 21:30:41 GMT&quot;,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line88">88</a>     #    &quot;x-amz-request-id&quot; =&gt; &quot;B7BC68F55495B1C8&quot;,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line89">89</a>     #    &quot;server&quot;           =&gt; &quot;AmazonS3&quot;,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line90">90</a>     #    &quot;content-length&quot;   =&gt; &quot;3418766&quot;}</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line91">91</a>     # </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line92">92</a>     # You can get and set metadata for an object:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line93">93</a>     # </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line94">94</a>     #   song.metadata</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line95">95</a>     #   # =&gt; {}</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line96">96</a>     #   song.metadata[:album] = &quot;A River Ain't Too Much To Love&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line97">97</a>     #   # =&gt; &quot;A River Ain't Too Much To Love&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line98">98</a>     #   song.metadata[:released] = 2005</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line99">99</a>     #   pp song.metadata</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line100">100</a>     #   {&quot;x-amz-meta-released&quot; =&gt; 2005, </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line101">101</a>     #     &quot;x-amz-meta-album&quot;   =&gt; &quot;A River Ain't Too Much To Love&quot;}</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line102">102</a>     #   song.store</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line103">103</a>     # </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line104">104</a>     # That metadata will be saved in S3 and is hence forth available from that object:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line105">105</a>     # </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line106">106</a>     #   song = S3Object.find('black-flowers.mp3', 'jukebox')</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line107">107</a>     #   pp song.metadata</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line108">108</a>     #   {&quot;x-amz-meta-released&quot; =&gt; &quot;2005&quot;, </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line109">109</a>     #     &quot;x-amz-meta-album&quot;   =&gt; &quot;A River Ain't Too Much To Love&quot;}</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line110">110</a>     #   song.metadata[:released]</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line111">111</a>     #   # =&gt; &quot;2005&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line112">112</a>     #   song.metadata[:released] = 2006</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line113">113</a>     #   pp song.metadata</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line114">114</a>     #   {&quot;x-amz-meta-released&quot; =&gt; 2006, </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line115">115</a>     #    &quot;x-amz-meta-album&quot;    =&gt; &quot;A River Ain't Too Much To Love&quot;}</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line116">116</a>     class S3Object &lt; Base</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line117">117</a>       class &lt;&lt; self        </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line118">118</a>         # Returns the value of the object with &lt;tt&gt;key&lt;/tt&gt; in the specified bucket.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line119">119</a>         #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line120">120</a>         # === Conditional GET options</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line121">121</a>         #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line122">122</a>         # * &lt;tt&gt;:if_modified_since&lt;/tt&gt; - Return the object only if it has been modified since the specified time, </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line123">123</a>         #   otherwise return a 304 (not modified).</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line124">124</a>         # * &lt;tt&gt;:if_unmodified_since&lt;/tt&gt; - Return the object only if it has not been modified since the specified time, </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line125">125</a>         #   otherwise raise PreconditionFailed.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line126">126</a>         # * &lt;tt&gt;:if_match&lt;/tt&gt; - Return the object only if its entity tag (ETag) is the same as the one specified, </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line127">127</a>         #   otherwise raise PreconditionFailed.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line128">128</a>         # * &lt;tt&gt;:if_none_match&lt;/tt&gt; - Return the object only if its entity tag (ETag) is different from the one specified, </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line129">129</a>         #   otherwise return a 304 (not modified).</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line130">130</a>         #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line131">131</a>         # === Other options</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line132">132</a>         # * &lt;tt&gt;:range&lt;/tt&gt; - Return only the bytes of the object in the specified range.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line133">133</a>         def value(key, bucket = nil, options = {}, &amp;block)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line134">134</a>           Value.new(get(path!(bucket, key, options), options, &amp;block))</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line135">135</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line136">136</a>         </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line137">137</a>         def stream(key, bucket = nil, options = {}, &amp;block)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line138">138</a>           value(key, bucket, options) do |response|</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line139">139</a>             response.read_body(&amp;block)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line140">140</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line141">141</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line142">142</a>         </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line143">143</a>         # Returns the object whose key is &lt;tt&gt;name&lt;/tt&gt; in the specified bucket. If the specified key does not</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line144">144</a>         # exist, a NoSuchKey exception will be raised.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line145">145</a>         def find(key, bucket = nil)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line146">146</a>           # N.B. This is arguably a hack. From what the current S3 API exposes, when you retrieve a bucket, it</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line147">147</a>           # provides a listing of all the files in that bucket (assuming you haven't limited the scope of what it returns).</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line148">148</a>           # Each file in the listing contains information about that file. It is from this information that an S3Object is built.</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line149">149</a>           #</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line150">150</a>           # If you know the specific file that you want, S3 allows you to make a get request for that specific file and it returns</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line151">151</a>           # the value of that file in its response body. This response body is used to build an S3Object::Value object. </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line152">152</a>           # If you want information about that file, you can make a head request and the headers of the response will contain </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line153">153</a>           # information about that file. There is no way, though, to say, give me the representation of just this given file the same </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line154">154</a>           # way that it would appear in a bucket listing.</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line155">155</a>           #</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line156">156</a>           # When fetching a bucket, you can provide options which narrow the scope of what files should be returned in that listing.</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line157">157</a>           # Of those options, one is &lt;tt&gt;marker&lt;/tt&gt; which is a string and instructs the bucket to return only object's who's key comes after</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line158">158</a>           # the specified marker according to alphabetic order. Another option is &lt;tt&gt;max-keys&lt;/tt&gt; which defaults to 1000 but allows you</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line159">159</a>           # to dictate how many objects should be returned in the listing. With a combination of &lt;tt&gt;marker&lt;/tt&gt; and &lt;tt&gt;max-keys&lt;/tt&gt; you can</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line160">160</a>           # *almost* specify exactly which file you'd like it to return, but &lt;tt&gt;marker&lt;/tt&gt; is not inclusive. In other words, if there is a bucket</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line161">161</a>           # which contains three objects who's keys are respectively 'a', 'b' and 'c', then fetching a bucket listing with marker set to 'b' will only</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line162">162</a>           # return 'c', not 'b'. </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line163">163</a>           #</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line164">164</a>           # Given all that, my hack to fetch a bucket with only one specific file, is to set the marker to the result of calling String#previous on</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line165">165</a>           # the desired object's key, which functionally makes the key ordered one degree higher than the desired object key according to </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line166">166</a>           # alphabetic ordering. This is a hack, but it should work around 99% of the time. I can't think of a scenario where it would return</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line167">167</a>           # something incorrect.</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line168">168</a>           </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line169">169</a>           # We need to ensure the key doesn't have extended characters but not uri escape it before doing the lookup and comparing since if the object exists, </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line170">170</a>           # the key on S3 will have been normalized</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line171">171</a>           key    = key.remove_extended unless key.valid_utf8?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line172">172</a>           bucket = Bucket.find(bucket_name(bucket), :marker =&gt; key.previous, :max_keys =&gt; 1)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line173">173</a>           # If our heuristic failed, trigger a NoSuchKey exception</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line174">174</a>           if (object = bucket.objects.first) &amp;&amp; object.key == key</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line175">175</a>             object </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line176">176</a>           else </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line177">177</a>             raise NoSuchKey.new(&quot;No such key `#{key}'&quot;, bucket)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line178">178</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line179">179</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line180">180</a>         </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line181">181</a>         # Makes a copy of the object with &lt;tt&gt;key&lt;/tt&gt; to &lt;tt&gt;copy_key&lt;/tt&gt;, preserving the ACL of the existing object if the &lt;tt&gt;:copy_acl&lt;/tt&gt; option is true (default false).</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line182">182</a>         def copy(key, copy_key, bucket = nil, options = {})</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line183">183</a>           bucket          = bucket_name(bucket)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line184">184</a>           source_key      = path!(bucket, key)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line185">185</a>           default_options = {'x-amz-copy-source' =&gt; source_key}</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line186">186</a>           target_key      = path!(bucket, copy_key)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line187">187</a>           redurning put(target_key, default_options) do</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line188">188</a>             acl(copy_key, bucket, acl(key, bucket)) if options[:copy_acl]</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line189">189</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line190">190</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line191">191</a>         </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line192">192</a>         # Rename the object with key &lt;tt&gt;from&lt;/tt&gt; to have key in &lt;tt&gt;to&lt;/tt&gt;.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line193">193</a>         def rename(from, to, bucket = nil, options = {})</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line194">194</a>           copy(from, to, bucket, options)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line195">195</a>           delete(from, bucket)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line196">196</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line197">197</a>         </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line198">198</a>         # Fetch information about the object with &lt;tt&gt;key&lt;/tt&gt; from &lt;tt&gt;bucket&lt;/tt&gt;. Information includes content type, content length,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line199">199</a>         # last modified time, and others.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line200">200</a>         #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line201">201</a>         # If the specified key does not exist, NoSuchKey is raised.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line202">202</a>         def about(key, bucket = nil, options = {})</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line203">203</a>           response = head(path!(bucket, key, options), options)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line204">204</a>           raise NoSuchKey.new(&quot;No such key `#{key}'&quot;, bucket) if response.code == 404</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line205">205</a>           About.new(response.headers)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line206">206</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line207">207</a>         </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line208">208</a>         # Checks if the object with &lt;tt&gt;key&lt;/tt&gt; in &lt;tt&gt;bucket&lt;/tt&gt; exists.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line209">209</a>         #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line210">210</a>         #   S3Object.exists? 'kiss.jpg', 'marcel'</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line211">211</a>         #   # =&gt; true</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line212">212</a>         def exists?(key, bucket = nil)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line213">213</a>           about(key, bucket)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line214">214</a>           true</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line215">215</a>         rescue NoSuchKey</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line216">216</a>           false</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line217">217</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line218">218</a>       </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line219">219</a>         # Delete object with &lt;tt&gt;key&lt;/tt&gt; from &lt;tt&gt;bucket&lt;/tt&gt;.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line220">220</a>         def delete(key, bucket = nil, options = {})</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line221">221</a>           # A bit confusing. Calling super actually makes an HTTP DELETE request. The delete method is</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line222">222</a>           # defined in the Base class. It happens to have the same name.</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line223">223</a>           super(path!(bucket, key, options), options).success?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line224">224</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line225">225</a>         </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line226">226</a>         # When storing an object on the S3 servers using S3Object.store, the &lt;tt&gt;data&lt;/tt&gt; argument can be a string or an I/O stream. </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line227">227</a>         # If &lt;tt&gt;data&lt;/tt&gt; is an I/O stream it will be read in segments and written to the socket incrementally. This approach </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line228">228</a>         # may be desirable for very large files so they are not read into memory all at once.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line229">229</a>         # </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line230">230</a>         #   # Non streamed upload</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line231">231</a>         #   S3Object.store('greeting.txt', 'hello world!', 'marcel')</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line232">232</a>         #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line233">233</a>         #   # Streamed upload</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line234">234</a>         #   S3Object.store('roots.mpeg', open('roots.mpeg'), 'marcel')</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line235">235</a>         def store(key, data, bucket = nil, options = {})</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line236">236</a>           validate_key!(key)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line237">237</a>           # Must build path before infering content type in case bucket is being used for options</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line238">238</a>           path = path!(bucket, key, options)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line239">239</a>           infer_content_type!(key, options)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line240">240</a>           </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line241">241</a>           put(path, options, data) # Don't call .success? on response. We want to get the etag.</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line242">242</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line243">243</a>         alias_method :create, :store</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line244">244</a>         alias_method :save,   :store</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line245">245</a>         </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line246">246</a>         # All private objects are accessible via an authenticated GET request to the S3 servers. You can generate an </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line247">247</a>         # authenticated url for an object like this:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line248">248</a>         #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line249">249</a>         #   S3Object.url_for('beluga_baby.jpg', 'marcel_molina')</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line250">250</a>         #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line251">251</a>         # By default authenticated urls expire 5 minutes after they were generated.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line252">252</a>         #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line253">253</a>         # Expiration options can be specified either with an absolute time since the epoch with the &lt;tt&gt;:expires&lt;/tt&gt; options,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line254">254</a>         # or with a number of seconds relative to now with the &lt;tt&gt;:expires_in&lt;/tt&gt; options:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line255">255</a>         #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line256">256</a>         #   # Absolute expiration date </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line257">257</a>         #   # (Expires January 18th, 2038)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line258">258</a>         #   doomsday = Time.mktime(2038, 1, 18).to_i</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line259">259</a>         #   S3Object.url_for('beluga_baby.jpg', </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line260">260</a>         #                    'marcel', </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line261">261</a>         #                    :expires =&gt; doomsday)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line262">262</a>         #   </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line263">263</a>         #   # Expiration relative to now specified in seconds </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line264">264</a>         #   # (Expires in 3 hours)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line265">265</a>         #   S3Object.url_for('beluga_baby.jpg', </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line266">266</a>         #                    'marcel', </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line267">267</a>         #                    :expires_in =&gt; 60 * 60 * 3)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line268">268</a>         #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line269">269</a>         # You can specify whether the url should go over SSL with the &lt;tt&gt;:use_ssl&lt;/tt&gt; option:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line270">270</a>         #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line271">271</a>         #   # Url will use https protocol</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line272">272</a>         #   S3Object.url_for('beluga_baby.jpg', </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line273">273</a>         #                    'marcel', </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line274">274</a>         #                    :use_ssl =&gt; true)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line275">275</a>         #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line276">276</a>         # By default, the ssl settings for the current connection will be used.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line277">277</a>         #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line278">278</a>         # If you have an object handy, you can use its &lt;tt&gt;url&lt;/tt&gt; method with the same objects:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line279">279</a>         #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line280">280</a>         #   song.url(:expires_in =&gt; 30)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line281">281</a>         #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line282">282</a>         # To get an unauthenticated url for the object, such as in the case</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line283">283</a>         # when the object is publicly readable, pass the</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line284">284</a>         # &lt;tt&gt;:authenticated&lt;/tt&gt; option with a value of &lt;tt&gt;false&lt;/tt&gt;.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line285">285</a>         #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line286">286</a>         #   S3Object.url_for('beluga_baby.jpg',</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line287">287</a>         #                    'marcel',</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line288">288</a>         #                    :authenticated =&gt; false)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line289">289</a>         #   # =&gt; http://s3.amazonaws.com/marcel/beluga_baby.jpg</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line290">290</a>         def url_for(name, bucket = nil, options = {})</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line291">291</a>           connection.url_for(path!(bucket, name, options), options) # Do not normalize options</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line292">292</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line293">293</a>         </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line294">294</a>         def path!(bucket, name, options = {}) #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line295">295</a>           # We're using the second argument for options</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line296">296</a>           if bucket.is_a?(Hash)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line297">297</a>             options.replace(bucket)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line298">298</a>             bucket = nil</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line299">299</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line300">300</a>           '/' &lt;&lt; File.join(bucket_name(bucket), name)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line301">301</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line302">302</a>     </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line303">303</a>         private</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line304">304</a>           </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line305">305</a>           def validate_key!(key)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line306">306</a>             raise InvalidKeyName.new(key) unless key &amp;&amp; key.size &lt;= 1024</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line307">307</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line308">308</a>           </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line309">309</a>           def infer_content_type!(key, options)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line310">310</a>             return if options.has_key?(:content_type)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line311">311</a>             if mime_type = MIME::Types.type_for(key).first</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line312">312</a>               options[:content_type] = mime_type.content_type</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line313">313</a>             end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line314">314</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line315">315</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line316">316</a>       </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line317">317</a>       class Value &lt; String #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line318">318</a>         attr_reader :response</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line319">319</a>         def initialize(response)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line320">320</a>           super(response.body)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line321">321</a>           @response = response</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line322">322</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line323">323</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line324">324</a>       </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line325">325</a>       class About &lt; Hash #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line326">326</a>         def initialize(headers)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line327">327</a>           super()</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line328">328</a>           replace(headers)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line329">329</a>           metadata</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line330">330</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line331">331</a>         </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line332">332</a>         def [](header)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line333">333</a>           super(header.to_header)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line334">334</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line335">335</a>         </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line336">336</a>         def []=(header, value)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line337">337</a>           super(header.to_header, value)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line338">338</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line339">339</a>         </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line340">340</a>         def to_headers</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line341">341</a>           self.merge(metadata.to_headers)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line342">342</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line343">343</a>           </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line344">344</a>         def metadata</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line345">345</a>           Metadata.new(self)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line346">346</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line347">347</a>         memoized :metadata</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line348">348</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line349">349</a>       </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line350">350</a>       class Metadata &lt; Hash #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line351">351</a>         HEADER_PREFIX = 'x-amz-meta-'</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line352">352</a>         SIZE_LIMIT    = 2048 # 2 kilobytes</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line353">353</a>         </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line354">354</a>         def initialize(headers)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line355">355</a>           @headers = headers</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line356">356</a>           super()</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line357">357</a>           extract_metadata!</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line358">358</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line359">359</a>         </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line360">360</a>         def []=(header, value)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line361">361</a>           super(header_name(header.to_header), value)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line362">362</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line363">363</a>         </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line364">364</a>         def [](header)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line365">365</a>           super(header_name(header.to_header))</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line366">366</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line367">367</a>         </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line368">368</a>         def to_headers</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line369">369</a>           validate!</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line370">370</a>           self</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line371">371</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line372">372</a>         </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line373">373</a>         private</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line374">374</a>           attr_reader :headers</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line375">375</a>           </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line376">376</a>           def extract_metadata!</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line377">377</a>             headers.keys.grep(Regexp.new(HEADER_PREFIX)).each do |metadata_header|</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line378">378</a>               self[metadata_header] = headers.delete(metadata_header)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line379">379</a>             end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line380">380</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line381">381</a>           </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line382">382</a>           def header_name(name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line383">383</a>             name =~ Regexp.new(HEADER_PREFIX) ? name : [HEADER_PREFIX, name].join</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line384">384</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line385">385</a>           </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line386">386</a>           def validate!</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line387">387</a>             invalid_headers = inject([]) do |invalid, (name, value)|</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line388">388</a>               invalid &lt;&lt; name unless valid?(value)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line389">389</a>               invalid</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line390">390</a>             end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line391">391</a>             </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line392">392</a>             raise InvalidMetadataValue.new(invalid_headers) unless invalid_headers.empty?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line393">393</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line394">394</a>           </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line395">395</a>           def valid?(value)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line396">396</a>             value &amp;&amp; value.size &lt; SIZE_LIMIT</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line397">397</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line398">398</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line399">399</a>       </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line400">400</a>       attr_writer :value #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line401">401</a>       </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line402">402</a>       # Provides readers and writers for all valid header settings listed in &lt;tt&gt;valid_header_settings&lt;/tt&gt;.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line403">403</a>       # Subsequent saves to the object after setting any of the valid headers settings will be reflected in </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line404">404</a>       # information about the object.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line405">405</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line406">406</a>       #   some_s3_object.content_type</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line407">407</a>       #   =&gt; nil</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line408">408</a>       #   some_s3_object.content_type = 'text/plain'</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line409">409</a>       #   =&gt; &quot;text/plain&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line410">410</a>       #   some_s3_object.content_type</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line411">411</a>       #   =&gt; &quot;text/plain&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line412">412</a>       #   some_s3_object.store</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line413">413</a>       #   S3Object.about(some_s3_object.key, some_s3_object.bucket.name)['content-type']</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line414">414</a>       #   =&gt; &quot;text/plain&quot;</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line415">415</a>       include SelectiveAttributeProxy #:nodoc</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line416">416</a>       </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line417">417</a>       proxy_to :about, :exclusively =&gt; false</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line418">418</a>       </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line419">419</a>       # Initializes a new S3Object.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line420">420</a>       def initialize(attributes = {}, &amp;block)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line421">421</a>         super</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line422">422</a>         self.value  = attributes.delete(:value) </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line423">423</a>         self.bucket = attributes.delete(:bucket)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line424">424</a>         yield self if block_given?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line425">425</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line426">426</a>       </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line427">427</a>       # The current object's bucket. If no bucket has been set, a NoBucketSpecified exception will be raised. For</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line428">428</a>       # cases where you are not sure if the bucket has been set, you can use the belongs_to_bucket? method.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line429">429</a>       def bucket</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line430">430</a>         @bucket or raise NoBucketSpecified</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line431">431</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line432">432</a>       </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line433">433</a>       # Sets the bucket that the object belongs to.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line434">434</a>       def bucket=(bucket)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line435">435</a>         @bucket = bucket</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line436">436</a>         self</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line437">437</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line438">438</a>       </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line439">439</a>       # Returns true if the current object has been assigned to a bucket yet. Objects must belong to a bucket before they</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line440">440</a>       # can be saved onto S3.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line441">441</a>       def belongs_to_bucket?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line442">442</a>         !@bucket.nil?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line443">443</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line444">444</a>       alias_method :orphan?, :belongs_to_bucket?</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line445">445</a>       </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line446">446</a>       # Returns the key of the object. If the key is not set, a NoKeySpecified exception will be raised. For cases</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line447">447</a>       # where you are not sure if the key has been set, you can use the key_set? method. Objects must have a key</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line448">448</a>       # set to be saved onto S3. Objects which have already been saved onto S3 will always have their key set.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line449">449</a>       def key</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line450">450</a>         attributes['key'] or raise NoKeySpecified</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line451">451</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line452">452</a>       </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line453">453</a>       # Sets the key for the current object.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line454">454</a>       def key=(value)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line455">455</a>         attributes['key'] = value</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line456">456</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line457">457</a>       </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line458">458</a>       # Returns true if the current object has had its key set yet. Objects which have already been saved will</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line459">459</a>       # always return true. This method is useful for objects which have not been saved yet so you know if you</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line460">460</a>       # need to set the object's key since you can not save an object unless its key has been set.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line461">461</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line462">462</a>       #   object.store if object.key_set? &amp;&amp; object.belongs_to_bucket?</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line463">463</a>       def key_set?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line464">464</a>         !attributes['key'].nil?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line465">465</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line466">466</a>       </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line467">467</a>       # Lazily loads object data. </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line468">468</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line469">469</a>       # Force a reload of the data by passing &lt;tt&gt;:reload&lt;/tt&gt;.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line470">470</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line471">471</a>       #   object.value(:reload)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line472">472</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line473">473</a>       # When loading the data for the first time you can optionally yield to a block which will</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line474">474</a>       # allow you to stream the data in segments.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line475">475</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line476">476</a>       #   object.value do |segment|</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line477">477</a>       #     send_data segment</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line478">478</a>       #   end </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line479">479</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line480">480</a>       # The full list of options are listed in the documentation for its class method counter part, S3Object::value.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line481">481</a>       def value(options = {}, &amp;block)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line482">482</a>         if options.is_a?(Hash)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line483">483</a>           reload = !options.empty?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line484">484</a>         else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line485">485</a>           reload  = options</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line486">486</a>           options = {}</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line487">487</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line488">488</a>         expirable_memoize(reload) do</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line489">489</a>           self.class.stream(key, bucket.name, options, &amp;block)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line490">490</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line491">491</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line492">492</a>       </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line493">493</a>       # Interface to information about the current object. Information is read only, though some of its data</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line494">494</a>       # can be modified through specific methods, such as content_type and content_type=.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line495">495</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line496">496</a>       #   pp some_object.about</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line497">497</a>       #     {&quot;last-modified&quot;    =&gt; &quot;Sat, 28 Oct 2006 21:29:26 GMT&quot;,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line498">498</a>       #      &quot;x-amz-id-2&quot;       =&gt;  &quot;LdcQRk5qLwxJQiZ8OH50HhoyKuqyWoJ67B6i+rOE5MxpjJTWh1kCkL+I0NQzbVQn&quot;,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line499">499</a>       #      &quot;content-type&quot;     =&gt; &quot;binary/octet-stream&quot;,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line500">500</a>       #      &quot;etag&quot;             =&gt; &quot;\&quot;dc629038ffc674bee6f62eb68454ff3a\&quot;&quot;,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line501">501</a>       #      &quot;date&quot;             =&gt; &quot;Sat, 28 Oct 2006 21:30:41 GMT&quot;,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line502">502</a>       #      &quot;x-amz-request-id&quot; =&gt; &quot;B7BC68F55495B1C8&quot;,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line503">503</a>       #      &quot;server&quot;           =&gt; &quot;AmazonS3&quot;,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line504">504</a>       #      &quot;content-length&quot;   =&gt; &quot;3418766&quot;}</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line505">505</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line506">506</a>       #  some_object.content_type</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line507">507</a>       #  # =&gt; &quot;binary/octet-stream&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line508">508</a>       #  some_object.content_type = 'audio/mpeg'</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line509">509</a>       #  some_object.content_type</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line510">510</a>       #  # =&gt; 'audio/mpeg'</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line511">511</a>       #  some_object.store</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line512">512</a>       def about</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line513">513</a>         stored? ? self.class.about(key, bucket.name) : About.new</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line514">514</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line515">515</a>       memoized :about</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line516">516</a>       </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line517">517</a>       # Interface to viewing and editing metadata for the current object. To be treated like a Hash.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line518">518</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line519">519</a>       #   some_object.metadata</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line520">520</a>       #   # =&gt; {}</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line521">521</a>       #   some_object.metadata[:author] = 'Dave Thomas'</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line522">522</a>       #   some_object.metadata</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line523">523</a>       #   # =&gt; {&quot;x-amz-meta-author&quot; =&gt; &quot;Dave Thomas&quot;}</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line524">524</a>       #   some_object.metadata[:author]</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line525">525</a>       #   # =&gt; &quot;Dave Thomas&quot;</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line526">526</a>       def metadata</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line527">527</a>         about.metadata</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line528">528</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line529">529</a>       memoized :metadata</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line530">530</a>       </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line531">531</a>       # Saves the current object with the specified &lt;tt&gt;options&lt;/tt&gt;. Valid options are listed in the documentation for S3Object::store.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line532">532</a>       def store(options = {})</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line533">533</a>         raise DeletedObject if frozen?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line534">534</a>         options  = about.to_headers.merge(options) if stored?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line535">535</a>         response = self.class.store(key, value, bucket.name, options)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line536">536</a>         bucket.update(:stored, self)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line537">537</a>         response.success?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line538">538</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line539">539</a>       alias_method :create, :store</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line540">540</a>       alias_method :save,   :store</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line541">541</a>       </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line542">542</a>       # Deletes the current object. Trying to save an object after it has been deleted with</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line543">543</a>       # raise a DeletedObject exception.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line544">544</a>       def delete</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line545">545</a>         bucket.update(:deleted, self)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line546">546</a>         freeze</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line547">547</a>         self.class.delete(key, bucket.name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line548">548</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line549">549</a>       </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line550">550</a>       # Copies the current object, given it the name &lt;tt&gt;copy_name&lt;/tt&gt;. Keep in mind that due to limitations in </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line551">551</a>       # S3's API, this operation requires retransmitting the entire object to S3.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line552">552</a>       def copy(copy_name, options = {})</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line553">553</a>         self.class.copy(key, copy_name, bucket.name, options)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line554">554</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line555">555</a>       </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line556">556</a>       # Rename the current object. Keep in mind that due to limitations in S3's API, this operation requires</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line557">557</a>       # retransmitting the entire object to S3.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line558">558</a>       def rename(to, options = {})</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line559">559</a>         self.class.rename(key, to, bucket.name, options)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line560">560</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line561">561</a>       </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line562">562</a>       def etag(reload = false)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line563">563</a>         return nil unless stored?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line564">564</a>         expirable_memoize(reload) do</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line565">565</a>           reload ? about(reload)['etag'][1...-1] : attributes['e_tag'][1...-1]</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line566">566</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line567">567</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line568">568</a>       </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line569">569</a>       # Returns the owner of the current object.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line570">570</a>       def owner </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line571">571</a>         Owner.new(attributes['owner'])</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line572">572</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line573">573</a>       memoized :owner</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line574">574</a>       </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line575">575</a>       # Generates an authenticated url for the current object. Accepts the same options as its class method</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line576">576</a>       # counter part S3Object.url_for.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line577">577</a>       def url(options = {})</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line578">578</a>         self.class.url_for(key, bucket.name, options)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line579">579</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line580">580</a>       </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line581">581</a>       # Returns true if the current object has been stored on S3 yet.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line582">582</a>       def stored?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line583">583</a>         !attributes['e_tag'].nil?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line584">584</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line585">585</a>       </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line586">586</a>       def ==(s3object) #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line587">587</a>         path == s3object.path</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line588">588</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line589">589</a>       </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line590">590</a>       def path #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line591">591</a>         self.class.path!(</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line592">592</a>           belongs_to_bucket? ? bucket.name : '(no bucket)', </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line593">593</a>           key_set?           ? key         : '(no key)'</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line594">594</a>         )</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line595">595</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line596">596</a>         </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line597">597</a>       # Don't dump binary data :)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line598">598</a>       def inspect #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line599">599</a>         &quot;#&lt;%s:0x%s '%s'&gt;&quot; % [self.class, object_id, path]</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line600">600</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line601">601</a>       </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line602">602</a>       private</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line603">603</a>         def proxiable_attribute?(name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line604">604</a>           valid_header_settings.include?(name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line605">605</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line606">606</a>         </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line607">607</a>         def valid_header_settings</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line608">608</a>           %w(cache_control content_type content_length content_md5 content_disposition content_encoding expires)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line609">609</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line610">610</a>     end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line611">611</a>   end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line612">612</a> end</pre></td>
          </tr>
        
      </tbody>
    </table>

    <p>Generated on Mon May 23 20:35:53 -0700 2011 with <a href="http://github.com/relevance/rcov">rcov 0.9.8</a></p>

  </body>
</html>
